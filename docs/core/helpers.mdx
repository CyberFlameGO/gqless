---
id: helpers
title: Core Helpers
sidebar_label: Helpers
---

## selectFields

Given an object or an array of objects, create a new object/array with the specified fields.

### Features and Limitations

- Allows to **select every field** of the proxy with a simple `"*"`.
- But when it encounters a field with arguments, it only returns the function back, since it can't assume your intent,
  even if all arguments are optional.
- Specified keys can be composed via `foo.bar`
- Specify recursive depth _(`1` by default)_
- Bad Type-safety, it just returns the same type as the input

### Examples

```ts
import { selectFields } from 'gqless';
import { query } from '../gqless';

const dataPicked = selectFields(query.user, ['name', 'address.city']);

const dataEverything1Depth = selectFields(query.user, '*');

const dataDeep = selectFields(query.user, '*', 2);
```

## getFields

Given an object, pre-access the specified fields, and returns the object back.

### Features and Limitations

- Good Type-Safety
- Allows keeping the proxies around.
- You can only specify the first level of scalars
- It doesn't do anything for objects inside objects

```ts
import { getFields, query, resolved } from 'gqless';

const data = await resolved(() => {
  return getFields(query.user, 'name', 'email');
});

// Proxy is kept, and you can pass it around safely
// data == query.user
```

### getArrayFields

We also have a helper to work with arrays, and works the same way as `getFields`.

```ts
import { getArrayFields, query, resolved } from 'gqless';

const data = await resolved(() => {
  return getArrayFields(query.allUsers, 'name', 'email');
});

// Proxy Array is kept, and you can pass it around safely
// data == query.allUsers
```

## Type Casters

If you find too annoying having to deal with `undefined` everywhere when
by logic you can be completely sure that in runtime you are not dealing with actual `undefined`s, `gqless` also exports no-op functions
with useful types that removes your `undefined`s.

:::caution
Use with caution, since you might encounter runtime errors if they are used unwisely
:::

:::tip
You can also use the types that are being used for this functions for types-only usage.
:::

### castNotSkeleton

Removes all the `undefined`s in 1 level of your object or array.

This next example is a perfectly safe place to use it, since here `id` and `name` will always be actual values in it's return value, not `undefined`.

```ts
import { castNotSkeleton } from 'gqless';
import { resolved, query } from '../gqless';

const data = await resolved(() => {
  const { id, name } = query.user;

  return castNotSkeleton({
    id,
    name,
  });
});

// query.user = { id: string | undefined; name: string | undefined; }
// data = { id: string; name: string }
```

### castNotSkeletonDeep

Removes all the `undefined`s **recursively** of your object or array.

This next example is a perfectly safe place to use it, since here all the fields returned will always be actual values in it's return value, not `undefined`.

```ts
import { castNotSkeletonDeep } from 'gqless';
import { resolved, query } from '../gqless';

const data = await resolved(() => {
  const { id, name, dogs } = query.user;

  return castNotSkeletonDeep({
    id,
    name,
    dogsNames: dogs.map((dog) => dog.name),
  });
});

// query.user = { id: string | undefined; name: string | undefined; dogs: { name: string | undefined }[] }
// data = { id: string; name: string; dogsNames: string[] }
```
